// The types in this file are transferred using JSON. The JSON is validated
// against a JSON Schema file `level.schema.json`, which is autogenerated from
// this file.
//
// Whenever types in this file are modified, the schema must be regenerated
// with:
// >  npx typescript-json-schema "src/level.ts" Level > src/level.schema.json

export type Direction = "U" | "R" | "D" | "L";
export type GemColour = "G" | "Y" | "K" | "R" | "B";

// Every Gadget corresponds to an unmodifiable element in the toolbox (i.e. an
// arrow cannot be rotated before placing on the board, hence we have distinct
// literals for each direction; A scale colour cannot be switched, so we have
// distinct literal for every colour; Basket colours and amount can be switched,
// so we have only one basket type). Gadget will be present in the level
// definition. A gadget that is configurable will be accompanied with
// GadgetAttributes.
//
// GadgetType is a more general type that will simplify the implementation of
// the engine.
export type GadgetType = "ARROW" | "EMPTY" | "SCALE" | "BASKET" | "FINISH";
export type Gadget =
  | "UPARROW"
  | "RIGHTARROW"
  | "DOWNARROW"
  | "LEFTARROW"
  | "EMPTY"
  | "GSCALE"
  | "YSCALE"
  | "KSCALE"
  | "RSCALE"
  | "BSCALE"
  | "BASKET"
  | "FINISH";

// The player may select how many gems and of which colour the basket gives on
// every visit.
export type BasketAttributes = {
  colour: GemColour;
  // Basket may either give a specific number of gems or the same amount as
  // dragon has some of other gems.
  count: number | GemColour;
};

export type GadgetAttributes = BasketAttributes;

export function gadgetType(gadget: Gadget): GadgetType {
  switch (gadget) {
    case "UPARROW":
    case "RIGHTARROW":
    case "DOWNARROW":
    case "LEFTARROW":
      return "ARROW";
    case "GSCALE":
    case "YSCALE":
    case "KSCALE":
    case "RSCALE":
    case "BSCALE":
      return "SCALE";
    case "BASKET":
      return "BASKET";
    case "EMPTY":
      return "EMPTY";
    case "FINISH":
      return "FINISH";
  }
}

export function gadgetDirection(gadget: Gadget): Direction | undefined {
  switch (gadget) {
    case "UPARROW":
      return "U";
    case "RIGHTARROW":
      return "R";
    case "DOWNARROW":
      return "D";
    case "LEFTARROW":
      return "L";
  }
  return undefined;
}

export function gadgetColourOut(gadget: Gadget): GemColour | undefined {
  switch (gadget) {
    case "GSCALE":
      return "G";
    case "YSCALE":
      return "Y";
    case "KSCALE":
      return "K";
    case "RSCALE":
      return "R";
    case "BSCALE":
      return "B";
  }
  return undefined;
}

export function coloursInGame(level: Level): GemColour[] {
  return Object.keys(level.goal) as GemColour[];
}

export function getDefaultAttributes(
  gadget: Gadget,
  cols: GemColour[] = []
): GadgetAttributes | undefined {
  if (gadget === "BASKET") {
    return { colour: cols[0], count: 1 };
  }
}

export type GadgetInfo = {
  gadget: Gadget;
  attributes?: GadgetAttributes;
};

// Gadget is an object that can be placed onto a field. GadgetOnBoard represents
// its placement.
export type GadgetsOnBoard = { [position: number]: GadgetInfo };

// Provides availability for different gadgets.
export type GadgetToolbox = { [index in Gadget]?: number };

// Stores the state of gems.
export type GemBalance = { [index in GemColour]?: number };

// The position of the dragon on the board is the main component of the state of
// the game.
export interface Dragon {
  position: number;
  direction: Direction;
  balance?: GemBalance;
}

// Interface Level describes the level of the Smok game.
export interface Level {
  width: number;
  height: number;
  board: GadgetsOnBoard;
  toolbox: GadgetToolbox;
  dragon: Dragon;
  // How many gems need to be laid on the scales for the gates to open.
  goal: GemBalance;
}
